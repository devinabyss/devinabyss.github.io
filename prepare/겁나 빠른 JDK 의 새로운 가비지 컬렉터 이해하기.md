겁나 빠른 JDK 의 새로운 가비지 컬렉터 이해하기



> ZGC, 셰넌도어, 그리고 G1 의 개선사항들이 개발자들을 무중단 자바에 더 가깝게 인도한다.



지난 6개월간 매우 흥미로운 개발사항들이 수면 아래 JDK 가비지 컬렉터 부분에서 발생했다. 이 글은 JDK12 부터 시작해 JDK13 까지 이어진 가비지 컬렉터들의 다양한 개선사항들을 다룬다. 우선 어플리케이션  (코드) 와 거의 동시에 동작하는 저지연 가비지 컬렉터 셰넌도어를 다루며, JDK11 부터 공개된 저지연 동시 가비지 컬렉터 ZGC 의 JDK12 개선사항, 마지막으로 JDK9 부터 기본 가비지 컬렉터로 동작하게 된 G1 GC 의 두가지 개선사항을 자세히 살펴볼 것이다.



# 가비지 컬렉터 둘러보기

자바가 개발자들에게 C 나 C++ 같은 구세대 언어와 차별적으로 선사한 가장 대표적 생산성 혜택은 가비지 컬렉션의 지원이다. 자바로 개발을 함으로 개발자들은 명시적으로 메모리 해제를 하지 않더라도 메모리 누수 현상을 걱정할 필요가 없으며, (적재된 메모리 내용의) 사용을 마치기 전 메모리를 해제를 하더라도 당신의 어플리케이션이 충돌날 것을 걱정할 필요도 없다. 가비지 컬렉션은 생산성의 승리임이 분명하지만, 개발자들은 그로인한 성능 저하를 몇번이고 고민하기에 마련이다. 가비지 컬렉션이 당신의 어플리케이션을 느리게 하지는 않을까? 개별적인 어플리케이션의 중지로 인해 사용자들의 사용성이 저해되지는 않을까?

많은 가비지 컬렉션 알고리즘들이 지난 몇년간 시도되고 테스트되며 지속적으로 성능을 향상시켜왔다. 이들 각 알고리즘들은 성능 향상을 위해 두가지 공통적 영역들이 고려되어 왔다. 첫째는 가비지 컬렉션의 처리량이다.  어플리케이션이 스스로의 코드를 실행하지 않고 멈춘채 가비지 컬렉션을 위해 얼만큼의 시간을 소요하는가?  둘째는 발생 된 지연, 즉 개별 일시 중지로 인한 지연 시간이다. 

JDK9 이전의 JDK 기본 GC 알고리즘이었던 병렬 GC 같이 중지를 자주 발생시키는 GC 들은 어플리케이션의 힙 사이즈를 증가시켜 처리량을 향상시킬 수 있지만, 중지 상태가 오래 지속되는 최악 케이스가 발생되기도 한다. 이런 특성을 가진 GC 들에게 큰 힙 사이즈는 가비지 컬렉션 주기를 저하시키는 것을 의미하며, 이는 그들의 컬렉션 작업을 보다 효과적으로 분할 시키지만, 각 주기마다 수행할 작업량이 많아지므로 개별 중지 시간은 보다 길어진다. 큰 사이즈의 힙 위에서 병렬 GC 를 사용하면 두드러진 중지 상태를 직면할 수 있는데, 이는 힙에 할당되어 있는 현세대 (Young Generation) 객체 계층들 사이에서 구세대로 수집하는데 시간이 걸리기 때문이다. 만약 당신이 상호작용이 배제된 배치 작업을 수행하는 어플리케이션을 구동한다면, 병렬 GC 는 매우 효율적인 컬렉터가 되어 줄 것이다.

G1 컬렉터는 Java 9 부터 오라클 JDK 와 OpenJDK 모두에게서 기본 GC 로 선정되었다. G1 의 



많은 GC 들의 (JDK9 이전의 기본 GC 정책이었던 병렬 GC 와 같은) 정지





JDK12 부터 포함된 ZGC 의 의 최근 개선사항들 역시 다룰 것이며, 마지막으로 가비지 퍼스트 (G1) GC 
겁나 빠른 JDK 의 새로운 가비지 컬렉터들 이해하기



> ZGC, 셰넌도어, 그리고 G1 의 개선사항들이 개발자들을 무중단 자바에 더 가깝게 인도한다.



지난 6개월간 매우 흥미로운 개발사항들이 수면 아래 JDK 가비지 컬렉터 부분에서 발생했다. 이 글은 JDK12 부터 시작해 JDK13 까지 이어진 가비지 컬렉터들의 다양한 개선사항들을 다룬다. 우선 어플리케이션  (코드) 와 거의 동시에 동작하는 저지연 가비지 컬렉터 셰넌도어를 다루며, Java 11 부터 공개된 저지연 동시 가비지 컬렉터 ZGC 의 JDK12 개선사항, 마지막으로 Java 9 부터 기본 가비지 컬렉터로 동작하게 된 G1 GC 의 두가지 개선사항을 자세히 살펴볼 것이다.



# 가비지 컬렉터들 둘러보기



## 가비지 컬렉터

자바가 개발자들에게 C 나 C++ 같은 구세대 언어와 차별적으로 선사한 가장 대표적 생산성 혜택은 가비지 컬렉션의 지원이다. 자바로 개발을 함으로 개발자들은 명시적으로 메모리 해제를 하지 않더라도 메모리 누수 현상을 걱정할 필요가 없으며, (적재된 메모리 내용의) 사용을 마치기 전 메모리를 해제를 하더라도 당신의 어플리케이션이 충돌날 것을 걱정할 필요도 없다. 가비지 컬렉션은 생산성의 승리임이 분명하지만, 개발자들은 그로인한 성능 저하를 몇번이고 고민하기에 마련이다. 가비지 컬렉션이 당신의 어플리케이션을 느리게 하지는 않을까? 개별적인 어플리케이션의 중지로 인해 사용자들의 사용성이 저해되지는 않을까?

많은 가비지 컬렉션 알고리즘들이 지난 몇년간 시도되고 테스트되며 지속적으로 성능을 향상시켜왔다. 이들 각 알고리즘들은 성능 향상을 위해 두가지 공통적 영역들이 고려되어 왔다. 첫째는 가비지 컬렉션의 처리량이다.  어플리케이션이 스스로의 코드를 실행하지 않고 멈춘채 가비지 컬렉션을 위해 얼만큼의 시간을 소요하는가?  둘째는 발생 된 지연, 즉 개별 일시 중지로 인한 지연 시간이다. 



## 병렬 GC

Java 9 이전의 기본 GC 알고리즘이었던 병렬 GC 같이 중지를 자주 발생시키는 GC 들은 어플리케이션의 힙 사이즈를 증가시켜 정지 한번의 처리량을 향상시킬 수 있지만, 중지 상태가 오래 지속되는 최악 케이스가 발생되기도 한다. 이런 특성을 가진 GC 들에게 큰 힙 사이즈는 가비지 컬렉션 주기를 저하시키는 것을 의미하며, 이는 그들의 컬렉션 작업을 보다 효과적으로 분할 시키지만, 각 주기마다 수행할 작업량이 많아지므로 개별 각각의 중지 시간은 보다 길어진다. 큰 사이즈의 힙 위에서 병렬 GC 를 사용하면 두드러진 중지 상태를 직면할 수 있는데, 이는 힙에 할당되어 있는 현세대 (Young Generation) 객체 계층들 사이에서 구세대로 수집하는데 시간이 걸리기 때문이다. 만약 당신이 상호작용이 배제된 배치 작업을 수행하는 어플리케이션을 구동한다면, 병렬 GC 는 매우 효율적인 컬렉터가 되어 줄 것이다.



## G1 GC

G1 컬렉터는 Java 9 부터 오라클 JDK 와 Open JDK 모두에게서 기본 GC 로 선정되었다. G1 의 가비지 컬렉션을 위한 접근법을 대략적으로 설명하자면, 사용자가 제공한 시간 목표값에 따라 GC 의 일시 정지 순간들을 분할하는 것이다. 만약 짧은 정지를 원한다면 목표 값을 짧게 지정하면 되고, GC 의 CPU 사용 빈도를 적게하고 어플리케이션에 더 할당하고 싶다면 큰 목표값을 설정하면 된다. 병렬 GC 가 처리량에 의거한 컬렉터라면, G1 이를 역으로 트레이드 오프 시켰다. 이는 한번의 처리량은 적지만 정지 시간들은 짧은 이점이 있다.

그렇다고해서, G1 이 가비지 컬렉팅 정지 시간의 절대자는 아니다. 힙의 크기가 매우 크거나 많은 객체들을 빠르게 할당하다보면, 작업량을 맞추기 위해 가비지 컬렉션 주기가 늘어나게 되고, 시간 분할 접근법은 한계에 부딪히기 시작한다. 비유를 하자면, 큰 조각의 음식을 작은 조각들로 잘게 쪼개면 우리의 소화 측면에선 수월해지겠지만, 접시에 음식들이 너무 많으면 저녁 식사를 위한 총 시간은 한참이 소요될 것이다. G1 가비지 컬렉션 역시 이와 마찬가지다.



## 그리고..

JDK12 에 등장한 저지연의 스페셜리스트, 섀넌도어 GC 는 위 사례와 같은 약점들을 공략한다. 섀넌도어는 대용량 힙 메모리에서도 일관된 정지 시간을  달성하며, 병렬 GC 에 비해 CPU 를 점유하는 시간은 조금 더 늘었지만, 정지 시간은 대폭 감소시켰다. (이게 무슨 개소리 말장난인가?) 이는 금융, 도박, 광고 같은 업계나 혹은 사용자들이 긴 정지 시간들로 인해 불만스러워할만한 인터렉티브 웹싸이트에게 매우 효과적인 저지연 상태를 선사할 것이다.

이 글에선 최신 버전들의 가비지 컬렉터들과 G1 의 최근 업데이트 사항들을 설명하고자 하며, 그 내용들이 당신의 어플리케이션에게 가장 적합한 기능들을 균형있게 사용할 수 있는 가이드가 되기를 바란다.



# 섀넌도어 ([Shenandoah]( https://wiki.openjdk.java.net/display/shenandoah/Main ))

섀넌도어는 JDK 12 릴리즈와 함께 새롭게 선보이게 된 가비지 컬렉터다. 섀넌도어의 개발 진척 사항들은 JDK 8 과 JDK 11 업데이트 버전들에도 반영되는 백포팅이 지원되고 있으므로, 당신이 JDK12 로의 환경 업그레이드에 문제가 있다 할지라도 당신의 시스템에 반영할 수 있다.  (역자 주 : LTS 만세.. 라지만, 오라클 JDK 는 논외이고, OpenJDK 역시 레드헷, 페도라 계열의 리눅스 배포판에 주로 포함되어 있음. [참조]( https://wiki.openjdk.java.net/display/shenandoah/Main#Main-Releases ))

우선 어떤 상황에서 섀넌도어가 탁월한지 살펴보고자 한다.  우리는 이 글에서 섀넌도어가 수면 아래 어떤식으로 동작하는지 자세하게 다루지는 않을 것이므로, 좀 더 기술적인 부분에 관심이 있다면 [첨부 기사](https://blogs.oracle.com/javamagazine/the-new-garbage-collectors-in-openjdk)와 [Open JDK 위키의 섀넌도어 페이지]( https://wiki.openjdk.java.net/display/shenandoah/Main#Main-Releases )를 찾아보면 된다.

섀넌도어로 인한 이득을 어




# 겁나 빠른 JDK 의 새로운 가비지 컬렉터들 이해하기

원문 :  [Understanding the JDK’s New Superfast Garbage Collectors]( https://cdn.app.compendium.com/uploads/user/e7c690e8-6ff9-102a-ac6d-e4aebca50425/34d3828b-c12e-4c7e-8942-b6b7deb02e12/File/01331a1ea2d4c196a756840f3e712ad1/understanding_the_jdk_s_new_superfast_garbage_collectors.pdf ) - [Oracle Java Magazine](https://blogs.oracle.com/javamagazine)



```
미천한 영어 실력 및 기술적 이해를 바탕으로 번역된 글이다보니 많이 엉성합니다.
특히나 섀넌도어 관련 부분 중 글 내용 안에선 도저히 적합한 근거를 찾을 수 없는 문장이 있는데,
언젠가의 제대로 알아야 할 숙제로 남겨 두는 것으로.. (마치 술은 마셨지만 음주운전은 하지 않았다 같은)
```



> ZGC, 셰넌도어, 그리고 G1 의 개선사항들이 무중단에 가까운 자바 세계로 개발자들을 인도한다.



지난 6개월간 매우 흥미로운 개발 사항들이 JDK 수면 아래의 가비지 컬렉터 부분에서 발생했다. 이 글은 JDK12 부터 시작해 JDK13 까지 이어진 가비지 컬렉터들의 다양한 개선사항들을 다룬다. 어플리케이션 우선 (코드) 과 거의 동시에 동작하는 저지연 가비지 컬렉터 셰넌도어를 다루게 될 것이며, 이어 Java 11 부터 공개된 저지연 동시 가비지 컬렉터 ZGC 의 JDK12 개선사항, 마지막으로 Java 9 부터 기본 가비지 컬렉터로 동작하게 된 G1 GC 의 두가지 개선사항을 자세히 살펴볼 것이다.



# 가비지 컬렉터들 둘러보기



## 가비지 컬렉터

자바가 개발자들에게 C 나 C++ 같은 구세대 언어와 차별적으로 선사한 가장 대표적 생산성 혜택은 가비지 컬렉션의 지원이다. 자바로 개발을 함으로 개발자들은 명시적으로 메모리 해제를 하지 않더라도 메모리 누수 현상을 걱정할 필요가 없으며, (적재된 메모리 내용의) 사용을 마치기 전 메모리를 해제를 하더라도 당신의 어플리케이션이 충돌날 것을 걱정할 필요도 없다. 가비지 컬렉션은 생산성의 승리임이 분명하지만, 개발자들은 그로인한 성능 저하를 몇번이고 고민하기에 마련이다. 가비지 컬렉션이 당신의 어플리케이션을 느리게 하지는 않을까? 개별적인 어플리케이션의 중지로 인해 사용자들의 사용성이 저해되지는 않을까?

많은 가비지 컬렉션 알고리즘들이 지난 몇년간 시도되고 테스트되며 지속적으로 성능을 향상시켜왔다. 이들 각 알고리즘들은 성능 향상을 위해 두가지 공통적 영역들이 고려되어 왔다. 첫째는 가비지 컬렉션의 처리량이다.  어플리케이션이 스스로의 코드를 실행하지 않고 멈춘채 가비지 컬렉션을 위해 얼만큼의 시간을 소요하는가?  둘째는 발생 된 지연, 즉 개별 일시 중지로 인한 지연 시간이다. 



## 병렬 GC (Parallel GC)

Java 9 이전의 기본 GC 알고리즘이었던 병렬 GC 같이 중지를 자주 발생시키는 GC 들은 어플리케이션의 힙 사이즈를 증가시켜 정지 한번의 처리량을 향상시킬 수 있지만, 중지 상태가 오래 지속되는 최악 케이스가 발생되기도 한다. 이런 특성을 가진 GC 들에게 큰 힙 사이즈는 가비지 컬렉션 주기를 저하시키는 것을 의미하며, 이는 그들의 컬렉션 작업을 보다 효과적으로 분할 시키지만, 각 주기마다 수행할 작업량이 많아지므로 개별 각각의 중지 시간은 보다 길어진다. 큰 사이즈의 힙 위에서 병렬 GC 를 사용하면 두드러진 중지 상태를 직면할 수 있는데, 이는 힙에 할당되어 있는 현세대 (Young Generation) 객체 계층들 사이에서 구세대로 수집하는데 시간이 걸리기 때문이다. 만약 당신이 상호작용이 배제된 배치 작업을 수행하는 어플리케이션을 구동한다면, 병렬 GC 는 매우 효율적인 컬렉터가 되어 줄 것이다.



## G1 GC

G1 컬렉터는 Java 9 부터 오라클 JDK 와 Open JDK 모두에게서 기본 GC 로 선정되었다. 가비지 컬렉션을 위한 G1 의 접근법을 간단히 요약하면, 사용자가 제공한 시간 목표값에 따라 GC 의 일시 정지 순간들을 분할하는 것이다. 만약 짧은 정지를 원한다면 목표 값을 짧게 지정하면 되고, GC 의 CPU 점유 빈도를 적게하고 어플리케이션에 더 할당하고 싶다면 큰 목표값을 설정하면 된다. 병렬 GC 가 처리량에 의거한 컬렉터라면, G1 이를 역으로 트레이드 오프 시켰다. 이 트레이드 오프는 한번의 처리량은 적지만 정지 시간들은 짧은 이점이 있다.

그렇다고해서 G1 을 가비지 컬렉팅 정지 시간의 절대자라 칭할 순 없다. 힙의 크기가 매우 크거나 수많은 객체들을 빠르게 할당하다보면 작업량을 맞추기 위해 가비지 컬렉션 주기가 늘어나게 되고, 시간 분할 접근법은 한계에 부딪히기 시작한다. 비유를 들어보면, 큰 조각의 음식을 작은 조각들로 잘게 쪼개면 우리의 소화 기능적 측면에선 수월하다고 할 수 있지만, 접시에 음식들이 너무 잘게 나눠져 있으면 저녁 식사를 위해 매우 긴 시간을 할애해야 할 것이다. G1 가비지 컬렉션의 특성이 이와 같다 할 수 있다.



## 그리고..

섀넌도어 가비지 컬렉터는 JDK12 에 등장한 저지연의 스페셜리스트로써 위 사례들의 약점들을 공략한다. 섀넌도어는 대용량 힙 메모리에서도 일관된 정지 시간을  달성하며, 병렬 GC 에 비해 CPU 를 점유하는 시간은 조금 더 늘었지만, 정지 시간은 대폭 감소시켰다. (이게 무슨 개소리 말장난인가?) 이는 금융, 도박, 광고 같은 업계나 혹은 사용자들이 긴 정지 시간들로 인해 불만스러워할만한 인터렉티브 웹싸이트에게 매우 효과적인 저지연 상태를 선사할 것이다.

이 글에선 최신 버전들의 가비지 컬렉터들과 G1 의 최근 업데이트 사항들을 설명하고자 하며, 그 내용들이 당신의 어플리케이션에게 가장 적합한 기능들을 균형있게 사용할 수 있는 가이드가 되기를 바란다.



# 섀넌도어 ([Shenandoah]( https://wiki.openjdk.java.net/display/shenandoah/Main ))

섀넌도어는 JDK 12 릴리즈와 함께 새롭게 선보이게 된 가비지 컬렉터다. 섀넌도어의 개발 진척 사항들은 JDK 8 과 JDK 11 업데이트 버전들에도 반영되는 백포팅이 지원되고 있으므로, 당신이 JDK12 로의 환경 업그레이드에 문제가 있다 할지라도 당신의 시스템에 반영할 수 있다.  (역자 주 : LTS 만세.. 라지만, 오라클 JDK 는 논외이고, OpenJDK 역시 레드헷, 페도라 계열의 리눅스 배포판에 주로 포함되어 있음. [참조]( https://wiki.openjdk.java.net/display/shenandoah/Main#Main-Releases ))

우선 어떤 상황에서 섀넌도어가 탁월한지 살펴보고자 한다.  우리는 이 글에서 섀넌도어가 보이지 않는 곳에서 어떤 식으로 동작하는지 자세하게 다루지는 않을 것이므로, 좀 더 기술적인 부분에 관심이 있다면 [첨부 기사](https://blogs.oracle.com/javamagazine/the-new-garbage-collectors-in-openjdk)와 [Open JDK 위키의 섀넌도어 페이지]( https://wiki.openjdk.java.net/display/shenandoah/Main#Main-Releases )를 찾아보면 된다.

섀넌도어로 얻을 수 있는 퍼포먼스 향상의 정도는 해당 어플리케이션의 부하량과 자체 특성에 의해 많이 좌우된다. 섀넌도어 팀은 SpecJBB 를 이용한 정지 시간 지연 벤치마크 테스트 결과를 공표한바 있으며, 그 결과는 표 1과 같다. 이 벤치마크는 일반적인 자바 비즈니스 어플리케이션 수행을 가정하여 진행되기는 했지만, 각자의 어플리케이션에 특성에 따라 차이가 있을 것이다.

이 벤치마크는 JDK9 시절의  G1 지연 시간을 기준으로 수치를 비교한다.  이는 구세대 JDK 로부터 업그레이드를 한다면 섀넌도어로 GC 를 변경함으로 충분히 효과를 얻을 수 있음을 의미한다.  JDK 12 이후의 버전으로 업그레이드를 한다면, G1 역시 그간 쭉 개선되어 왔으므로 상기 표기된 수치보다 좋은 성능을보일 것이다.

섀넌도어가 G1 과 차별되는 핵심 전략은 컬렉션 주기마다 어플리케이션 작업 쓰레드와 동시에 가비지 컬렉션 쓰레드를 동작시키면서 보다 많은 처리를 하는 것이다. G1 은 힙 영역 안에서 객체를 이동시키고 제거하는 동작을 오직 어플리케이션의 정지를 통해서만 수행하지만, 섀넌도어는 어플리케이션이 동작하는 것과 동시에 객체의 재할당을 수행한다. 이같은 동시 재할당을 수행하기 위해서 브룩스 포인터 (Brooks Pointer) 란 명칭으로 알려진 방법이 사용된다.  이 포인터는 섀넌도어 힙 영역 내에 각 객체들이 가지는 추가 필드이며, 각 객체가 자신이 돌아갈 곳을 저장한다.

섀넌도어가 브룩스 포인터를 사용하는 것은 객체를 이동시킬 때 힙 내에서 그 객체를 참조하고 있는 모든 객체들의 수정해야 하는 번거로움을 해소하기 위함이다. 섀넌도어는 어떤 오브젝트를 새로운 위치로 이동시킬 때, 오래된 브룩스 포인터를 그대로 두면서 참조 포인터가 이동시킨 객체의 새로운 위치를 가르키도록 한다. 객체 참조가 끝나면, 어플리케이션은 브룩스 포인터에 의해 인도된 참조 포인터를 따라 객체의 새로운 위치를 참조하게 되는 것이다. 오래된 객체와 객체를 가르키는 포인터는 결국 언젠가는 청소되어야 하는 요소들인데, 섀넌도어는 청소 동작을 객체의 이동과 분리시킴으로써 보다 쉽게 동시에 객체의 재할당을 수행하게 된다.

Java 12 이상의 버전에서 섀넌도어를 활성화시키려면, 어플리케이션에 다음과 같은 옵션을 주면 된다.

```terminal
-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahG
```

Java 12 이상을 사용할 준비가 되지 않았더라도, 섀넌도어는 Java 8 과 Java 11 에 백포트가 지원되고 있다. 다만 오라클 JDK 배포 버전들은 섀넌도어를 지원하지 않으며, 일부 OpenJDK 배포자들은 섀넌도어를 기본 GC 알고리즘으로 지정하고 있다. 보다 자세한 사항은 다음 스펙 링크에서 확인할 수 있다. [JEP 198]( https://openjdk.java.net/jeps/189 )

동시성 가비지 컬렉션의 관점에서 섀넌도어가 유일한 선택지는 아니며, JDK 12 에 들어 개선되며 OpenJDK 와 함께 배포되는 (오라클 배포 버전도 포함) ZGC 는  또다른 가비지 컬렉터 선택지가 될 것이다. 가비지 컬렉션으로 인한 중단 문제로 인해 섀넌도어의 사용을 고려하고 있다면 다음 파트에서 다뤄질 ZGC 에 대해서도 살펴볼 필요가 있다.



# 동시 클래스 언로드의 ZGC

 ZGC 의 최우선 목표들은 저지연과 확장성, 그리고 손쉬운 사용법이다. ZGC 는 이를 위해 자바 어플리케이션이 쓰레드 스택 탐지 동작을 제외한 모든 가비지 컬렉션 동작 중 로직 동작을 수행할 수 있도록 허용하며, 수백 MB 단위부터 TB 단위에 이르는 자바 힙 영역을 대게 2ms 이내의 매우 짧으면서도 일관된 정지시간 동안 계량화한다.

예측할 수 있는 짧은 정지 시간은 어플리케이션 개발자와 시스템 아키텍트 모두에게 매우 긍정적 영향을 미친다. 개발자들은 더이상 가비지 컬렉션 정지를 걱정하며 정교한 코드를 고민할 필요가 없고, 시스템 아키텍트들은 다양한 핵심 유즈 케이스들의 저지연 상태를 확보하기 위해 GC 성능 개선에 목메달 필요가 없어진다. 이는 빅 데이터를 다루며 큰 메모리를 필요로 하는 어플리케이션에 적합하다. 혹은 적은 메모리를 사용하지만 극도의 저지연이 요구되는 어플리케이션 역시 마찬가지로 적합하다.

ZGC 는 실험적 기능으로  JDK 11 에서 추가되었다. 이어 JDK12 에 와선 동시 클래스 언로드 지원이 추가되었는데, 이는 자바 어플리케이션이 정지 없는 클래스 언로드를 수행할 수 있게 한다.

동시 클래스 언로드는 매우 복잡하며, 심지어 전통적으로 완전 정지 상태에서 수행되던 동작이다. 더이상 필요하지 않은 클래스들의 집합을 확정하는 것은 참조 동작들을 우선 수행한 뒤, Object.finalize() 메소드의 구현체와 같은 종결자들을 수행해야 한다. 무분별한 연결 체인들로 인해 종결자가 의도치 않게 클래스들을 계속 유지시킬 수 있으므로,  참조 동작 실행 중 종결자들이 접근할 수 있는 객체들은 반드시 종결자에 의해 종료되어야 한다. 애석하게도 종결자들이 접근 가능한 모든 객체들을 처리하는 것은 꽤 오랜 시간이 걸린다. 최악의 상황은 하나의 종결자가 힙의 모든 객체들로 접근할 수 있는 경우다. ZGC 는 JDK11 부터 참조 동작을 동시다발적으로 수행한다.

참조 동작 수행이 종료되면 ZGC 는 어떤 클래스들이 더이상 필요하지 않은지를 알게 되고, 이 불필요한 클래스들로부터 발생한 오래되고 잘못된 데이터들과 데이터 구조들의 청소를 실시한다.